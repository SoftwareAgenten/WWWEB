#!/usr/bin/env node
'use strict'

// Node Modules

const yargs = require('yargs')
const axios = require('axios')
const colors = require('colors')

// Modules Setup

const argv = yargs
  .usage('usage: $0 -d domain [--rest=0]')
  // --domain
  .demand('d')
  .alias('d', 'domain')
  .nargs('d', 1)
  .describe('d', 'Initial domain')
  // --rest
  .default('rest', 0)
  .alias('rest', 'r')
  .describe('r', 'Seconds to rest between requests')
  // --verbose
  .default('verbose', false)
  .alias('verbose', 'v')
  .describe('v', 'Verbose output of what is going on')
  // --help
  .help('help')
  .alias('help', 'h')
  // examples
  .example('$0 -d example.org --rest=1', 'start crawling at example.org with 1 second rest between requests')
  .argv

// Classes

class RuleSet {
  constructor(userAgent, rules) {
    this.userAgent = userAgent
    this.rules = rules
  }
}

class DomainSettings {
  constructor(domain, rulesets) {
    this.domain = domain
    this.rulesets = rulesets
  }
  
  addRuleset(ruleset) {
    this.rulesets.push(ruleset)
  }
}

class Record {
  constructor(timestamp, domainSettings) {
    this.timestamp
    this.domainSettings = domainSettings
  }
}

class Protocol {
  constructor() {
    this.records = []
  }
  
  addRecord(record) {
    this.records.push(record)
  }
}

class Report {
  constructor(initialAddress) {
    this.initialAddress = initialAddress
    this.protocol = new Protocol()
  }
}

// Constants

const HTML_LINK_REGEX = new RegExp(String.raw`<\s*a.*?href\s*=\s*["']\s*https?:\/\/.*?((?:[\w\d-]+\.)+[\w\d-]+).*?["'][^>]*>.*?<\s*?\/\s*?a\s*?>`, 'ig')

// Main Routine

const WWWEB = (() => {
  const self = {
    initialAddress: null,
    restTime: 0, // seconds
    report: null,
    domainStack: [],
    processedDomains: []
  }
  
  self.init = (initialAddress, restTime) => {
    self.initialAddress = initialAddress
    self.restTime = restTime
    self.report = new Report(initialAddress)
  }
  
  const processDomain = domain => {
    console.log(`* processing ${domain.blue}...`)
    
    return new Promise((resolve, reject) => {
      axios.get(`http://${domain}/`).then(response => {
        console.log('├ '+'found startpage'.green)
        
        const HTML = response.data
        let newDomains = []
        let match = null
        
        while (match = HTML_LINK_REGEX.exec(HTML)) {
          newDomains.push(match[1])
        }
        
        newDomains
          .filter((x, index) => newDomains.indexOf(x) === index) // unique
          .filter(x => x !== domain)
          .filter(x => self.processedDomains.indexOf(x) === -1)
          .forEach(x => self.domainStack.push(x))
      }, error => {
        console.log('├ '+'no startpage'.red)
        // TODO: handle no new domains
      }).then(() => {
        axios.get(`http://${domain}/robots.txt`).then(response => {
          console.log('└ '+'found robots.txt'.green)
          // TODO: interpret robots.txt
          let domainSettings = null
          resolve(domainSettings)
        }, error => {
          console.log('└ '+'no robots.txt'.red)
          // TODO: handle no robots.txt
          reject()
        })
      })
    })
  }
  
  const crawl = () => {
    if (self.domainStack.length > 0) {
      // rest
      setTimeout(function () {
        performRoutine(self.domainStack.pop())
      }, self.restTime)
      
      if (argv.verbose && self.restTime > 0) {
        console.log(`resting for ${self.restTime}s...`)
      }
    } else {
      // terminate
      console.log('no next domain to process')
    }
  }
  
  const performRoutine = domain => {
    let timestamp = Date.now()
    
    processDomain(domain).then(domainSettings => {
      let newRecord = new Record(timestamp, domainSettings)
      
      // store new record and remember domain
      self.report.protocol.addRecord(newRecord)
      self.processedDomains.push(domain)
      
      crawl()
    }).catch(crawl)
  }
  
  self.run = () => {
    performRoutine(self.initialAddress)
  }
  
  return self
}())

// Startup Logic

WWWEB.init(argv.domain, argv.rest)
WWWEB.run()