#!/usr/bin/env node
'use strict'

// Node Modules

const yargs = require('yargs')
const axios = require('axios')
const colors = require('colors')

// Modules Setup

const argv = yargs
  .usage('usage: $0 -d <domain> [--rest <seconds>] [-v]')
  // --domain
  .demand('d')
  .alias('d', 'domain')
  .nargs('d', 1)
  .describe('d', 'Initial domain')
  // --rest
  .default('rest', 0)
  .alias('rest', 'r')
  .describe('r', 'Seconds to rest between requests')
  // --verbose
  .boolean('verbose')
  .alias('verbose', 'v')
  .describe('v', 'Verbose output of what is going on')
  // --help
  .help('help')
  .alias('help', 'h')
  // examples
  .example('$0 -d example.org --rest=1', 'start crawling at example.org with 1 second rest between requests')
  .argv

// Classes

class RuleSet {
  constructor(userAgent, rules = []) {
    this.userAgent = userAgent
    this.rules = rules
  }
  
  addRule(rule) {
    this.rules.push(rule)
  }
}

class DomainSettings {
  constructor(domain, rulesets = []) {
    this.domain = domain
    this.rulesets = rulesets
  }
  
  addRuleset(ruleset) {
    this.rulesets.push(ruleset)
  }
}

class Record {
  constructor(timestamp, domainSettings) {
    this.timestamp
    this.domainSettings = domainSettings
  }
}

class Protocol {
  constructor() {
    this.records = []
  }
  
  addRecord(record) {
    this.records.push(record)
  }
}

class Report {
  constructor(initialAddress) {
    this.initialAddress = initialAddress
    this.protocol = new Protocol()
  }
}

// Constants

const HTML_LINK_REGEX = /<\s*a.*?href\s*=\s*["']\s*https?:\/\/.*?((?:[\w\d-]+\.)+[\w\d-]+).*?["'][^>]*>.*?<\s*?\/\s*?a\s*?>/ig
const GRAP_UA_REGEX = /User-agent:\s*(.*)/i
const GRAP_RULE_REGEX = /Disallow:\s*(.*)/i

// Main Routine

const WWWEB = (() => {
  const self = {
    initialAddress: null,
    restTime: 0, // seconds
    report: null,
    domainStack: [],
    processedDomains: []
  }
  
  self.init = (initialAddress, restTime = 0) => {
    self.initialAddress = initialAddress
    self.restTime = restTime
    self.report = new Report(initialAddress)
  }
  
  const processDomain = domain => {
    console.log(`* processing ${domain.blue}...`)
    
    return new Promise((resolve, reject) => {
      axios.get(`http://${domain}/`).then(response => {
        console.log('├ '+'found startpage'.green)
        
        const HTML = response.data
        let newDomains = []
        let match = null
        
        while (match = HTML_LINK_REGEX.exec(HTML)) {
          newDomains.push(match[1])
        }
        
        newDomains
          .filter((x, index) => newDomains.indexOf(x) === index) // unique only
          .filter(x => x !== domain) // filter out current domain
          .filter(x => self.processedDomains.indexOf(x) === -1) // keep unknown
          .forEach(x => self.domainStack.push(x)) // add new domains to stack
      }, error => {
        console.log('├ '+'no startpage'.red)
      }).then(() => {
        axios.get(`http://${domain}/robots.txt`).then(response => {
          // Check Content-Type
          if (!/text\/plain/i.test(response.headers['content-type'])) {
            console.log('└ '+'invalide robots.txt'.red)
            reject()
            return
          }
          
          console.log('└ '+'found robots.txt'.green)
          
          let domainSettings = new DomainSettings(domain)
          const lines = response.data.split('\n')
          let currentRuleset = null
          
          // Parse robots.txt, Line by Line
          lines.forEach(line => {
            if (/^User-agent:/.test(line)) {
              const UA = GRAP_UA_REGEX.exec(line)[1]
                            
              if (currentRuleset !== null) {
                // Save old Ruleset
                domainSettings.addRuleset(currentRuleset)
              }
              currentRuleset = new RuleSet(UA)
            }
            
            else if (/^Disallow:/.test(line)) {
              const rule = GRAP_RULE_REGEX.exec(line)[1]
              currentRuleset.addRule(rule)
            }
          })
          
          // Add last Ruleset to DomainSettings
          domainSettings.addRuleset(currentRuleset)
          
          if (argv.verbose && currentRuleset === null) {
            console.log('[warning] robots.txt did not specify any rules'.yellow)
          }
          
          resolve(domainSettings)
        }, error => {
          console.log('└ '+'no robots.txt'.red)
          // TODO: handle no robots.txt
          reject()
        })
      })
    })
  }
  
  const crawl = () => {
    if (self.domainStack.length > 0) {
      // rest
      setTimeout(function () {
        performRoutine(self.domainStack.pop())
      }, self.restTime * 1000)
      
      if (argv.verbose && self.restTime > 0) {
        console.log(`[info] resting for ${self.restTime}s...`)
      }
    } else {
      // terminate
      console.log('no next domain to process')
    }
  }
  
  const performRoutine = domain => {
    let timestamp = Date.now()
    
    processDomain(domain).then(domainSettings => {
      let newRecord = new Record(timestamp, domainSettings)
      
      // store new record and remember domain
      self.report.protocol.addRecord(newRecord)
      self.processedDomains.push(domain)
      
      crawl()
    }).catch(crawl)
  }
  
  self.run = () => {
    performRoutine(self.initialAddress)
  }
  
  return self
})()

// Startup Logic

WWWEB.init(argv.domain, argv.rest)
WWWEB.run()